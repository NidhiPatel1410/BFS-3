// In this problem, going exhaustive, removing one one char at a time, and checking each new substring generated by removing that char
// if it is valid, adding it to the result and turning the flag as true so in BFS it will not go on next level. And in dfs, keeping
// a max variable, which stores the length of valid str found, then when next valid str is found, checking its length if it is > then
// the current max, removing everything from result, updating max and adding this curr str to the result. 

// Time Complexity : Exponential
// Space Complexity : Recursive stack space, O(n) 
// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : no
// BFS
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        // Base case
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }
        // For BFS queue
        Queue<String> q = new LinkedList<>();
        // For maintaining visted strings, hashset
        HashSet<String> visited = new HashSet<>();
        // Flag for the string found
        boolean flag = false;
        // Result list
        List<String> result = new ArrayList<>();
        // Add the first string to the queue
        q.add(s);
        // Also add to the visited
        visited.add(s);
        // Loop till queue is not empty
        while (!q.isEmpty()) { // previously it was while(!q.isEmpty() && !flag )
            // int size=q.size();
            // for(int i=0;i<size;i++){
            // Poll the current string
            String curr = q.poll();
            // Check if it is a valid string
            if (isValid(curr)) {
                // Set the flag to true so it will not go on next level i.e it will not add the
                // childrens of string
                flag = true;
                // Also add the string to the result
                result.add(curr);
            }
            // Else if the current string is not valid, only if the flag is false, i.e we
            // have not yet found any valid string on current level, only then go and add
            // it's children to the queue
            else if (flag == false) {
                // Loop for all the childrens
                for (int j = 0; j < curr.length(); j++) {
                    // Take one char at a time
                    char c = curr.charAt(j);
                    // If it is a-z, ignore
                    if (c >= 'a' && c <= 'z') {
                        continue;
                    }
                    // Else if it is a bracket, go on and remove this bracket from the string and
                    // generate the string
                    String child = curr.substring(0, j) + curr.substring(j + 1);
                    // Check if the child is not in visited and flag is also not true, only then add
                    // to queue and visited set
                    if (!visited.contains(child) && !flag) {
                        q.add(child);
                        visited.add(child);
                    }
                }
            }
            // }
        }
        // Return result
        return result;
    }

    private boolean isValid(String str) {
        // For isValid, we add 1 for every openeing bracket and substract one for every
        // closing bracket, in end if the count is zero, we return true
        int count = 0;
        for (int k = 0; k < str.length(); k++) {
            char c = str.charAt(k);
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
                // If in between, the count becomes negative, the string is invalid so return
                // false
                if (count < 0) {
                    return false;
                }
            }
        }
        // Return true if count is 0
        return count == 0;
    }
}

// DFS
class Solution {
    HashSet<String> visited;
    List<String> result;
    int max = 0;

    public List<String> removeInvalidParentheses(String s) {
        // Base Case
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }
        visited = new HashSet<>();
        result = new ArrayList<>();
        dfs(s);
        return result;
    }

    private void dfs(String s) {
        // If the length of current string is less than the max, return
        if (s.length() < max) {
            return;
        }
        // If visited already contains this string, return
        if (visited.contains(s)) {
            return;
        }
        // Check if it is a valid
        if (isValid(s)) {
            // If length greater than max
            if (s.length() > max) {
                // Update max
                max = s.length();
                // Empty result
                result = new ArrayList<>();
                // Add this current string to the result
                result.add(s);
            }
            // Else if the length is equal
            else if (max == s.length()) {
                // Simply add to the existing result
                result.add(s);
            }
        }
        // Add to the set
        visited.add(s);
        // Explore all it's children
        for (int j = 0; j < s.length(); j++) {
            char c = s.charAt(j);
            if (c >= 'a' && c <= 'z') {
                continue;
            }
            String child = s.substring(0, j) + s.substring(j + 1);
            // Call dfs on it
            dfs(child);
        }
    }

    private boolean isValid(String str) {
        int count = 0;
        for (int k = 0; k < str.length(); k++) {
            char c = str.charAt(k);
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
                if (count < 0) {
                    return false;
                }
            }
        }
        return count == 0;
    }
}